-------------------------------------------------------------------------------
--
--  Copyright (c) 2023 Francesc Rocher <francesc.rocher@gnail.com>
--  SPDX-License-Identifier: CC-BY-NC-SA-4.0
--  https://creativecommons.org/licenses/by-nc-sa/4.0/
--
--  ---------------------------------------------------------------------------
--
--  The following problem is taken from Project Euler:
--
--                 https://projecteuler.net/problem=29
--
--  Distinct powers
--  ---------------
--
--  Consider all integer combinations of a^b for  2 ≤ a ≤ 5  and  2 ≤ b ≤ 5:
--
--                 2^2=4,  2^3=8,   2^4=16,  2^5=32
--                 3^2=9,  3^3=27,  3^4=81,  3^5=243
--                 4^2=16, 4^3=64,  4^4=256, 4^5=1024
--                 5^2=25, 5^3=125, 5^4=625, 5^5=3125
--
--  If they are then placed in numerical order, with any repeats removed, we
--  get the following sequence of 15 distinct terms:
--
--      4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125
--
--  How many distinct terms are in the sequence generated by a^b for
--
--             2 ≤ a ≤ 100  and  2 ≤ b ≤ 100?
--
-------------------------------------------------------------------------------

with Euler_Tools; use Euler_Tools;

package body P0029_Distinct_Powers is

   overriding function Get_Answer (P : P0029_Type) return String is
      use List_Package;
      Answer : Integer_Type := 99**2;
   begin

      for Base in 2 .. 100 loop
         for Exp in 2 .. 100 loop
            declare
               Base_New            : Integer_Type;
               Base_Factors : constant List_Type := Prime_Factors (Base);
               Base_Factors_Equals : constant Boolean := Equals (Base_Factors);
               Exp_Factors         : List_Type          := Prime_Factors (Exp);
               Factors             : List_Type;
               Length_Factors      : Natural;
            begin
               --  Try to increase the base and reduce the exponent so that
               --  a^b = p^q with 2 <= a < p <= 100, 2 <= q <= 100, e.g.
               --
               --    6⁴ = 6⁽²²⁾ = (6²)² = 36²
               --
               --  Then, considering that numbers with greater base are always
               --  counted (36²), don't count equivalent numbers with lesser
               --  base (6⁴).
               --
               --  If Equals (Base_Factors), then use the number of factors of
               --  the Base, Length (Base_Factors), as a new exponent factor, e.g.
               --
               --    27¹⁰⁰ = (3³)⁽²²⁵⁵⁾ = 3⁽²²⁵⁵³⁾ = (3⁴)⁽⁵⁵³⁾ = 81⁷⁵
               --
               --  The list of factor ⁽²²⁵⁵³⁾ must be sorted to make sure the
               --  new base is found.

               if Base_Factors_Equals then
                  for F of Prime_Factors (Length (Base_Factors)) loop
                     Exp_Factors.Append (F);
                  end loop;
                  Sort (Exp_Factors);
               end if;
               Length_Factors := Length (Exp_Factors);

               Loop_Over_Exponent_Factors :
               for I in 1 .. Length_Factors loop
                  if Base_Factors_Equals then
                     Base_New := Base_Factors.First_Element;
                  else
                     Base_New := Base;
                  end if;
                  Factors := Exp_Factors;
                  loop
                     begin
                        Base_New := @**Factors.First_Element;
                     exception
                        when Constraint_Error =>
                           Base_New := Integer_Type'Last;
                     end;
                     Factors.Delete_First;
                     exit when Base_New > Base;
                  end loop;
                  if Base_New <= 100 and then Product (Factors) in 2 .. 100
                  then
                     --  Duplicate value found
                     Answer := @ - 1;
                     exit Loop_Over_Exponent_Factors;
                  end if;

                  --  keep trying other exponent factors
                  Exp_Factors.Append (Exp_Factors.First_Element);
                  Exp_Factors.Delete_First;
               end loop Loop_Over_Exponent_Factors;
            end;
         end loop;
      end loop;

      return To_String (Answer);
   end Get_Answer;

end P0029_Distinct_Powers;
